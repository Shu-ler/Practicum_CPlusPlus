#pragma once

#include <string>

class Person;

// Наблюдатель за состоянием человека.
class PersonObserver {
public:
	// Этот метод вызывается, когда меняется состояние удовлетворённости человека
	virtual void OnSatisfactionChanged(Person& /*person*/, int /*old_value*/, int /*new_value*/) {
		// Реализация метода базового класса ничего не делает
	}

protected:
	// Класс PersonObserver не предназначен для удаления напрямую
	~PersonObserver() = default;
};

/*
	Человек.
	При изменении уровня удовлетворённости уведомляет
	связанного с ним наблюдателя
*/
class Person {
public:
	Person(const std::string& name, int age) 
		: name_{ name }
		, age_{ age } {
	}

	virtual ~Person() = default;

	int GetSatisfaction() const {
		return satisfaction_;
	}

	const std::string& GetName() const {
		return name_;
	}

	// «Привязывает» наблюдателя к человеку. Привязанный наблюдатель
	// уведомляется об изменении уровня удовлетворённости человека
	// Новый наблюдатель заменяет собой ранее привязанного
	// Если передать nullptr в качестве наблюдателя, это эквивалентно отсутствию наблюдателя
	void SetObserver(PersonObserver* observer) {
		observer_ = observer;
	}

	PersonObserver* GetObserver() {
		return observer_;
	}

	int GetAge() const {
		return age_;
	}

	// Увеличивает на 1 количество походов на танцы
	// Увеличивает удовлетворённость на 1
	void Dance() {
		++dance_count_;
		AfterDance();
	}

	int GetDanceCount() const {
		return dance_count_;
	}

	// Прожить день. Реализация в базовом классе ничего не делает
	virtual void LiveADay() {
		// Подклассы могут переопределить этот метод
	}

protected:
	virtual void AfterDance() {
		SetSatisfaction(satisfaction_ + 1);
	}

	void SetSatisfaction(int sat) {
		if (satisfaction_ != sat) {
			int old_satisfaction = satisfaction_;
			satisfaction_ = sat;
			if (observer_) {
				observer_->OnSatisfactionChanged(*this, old_satisfaction, satisfaction_);
			}
		}
	}

private:
	std::string name_;
	PersonObserver* observer_ = nullptr;
	int satisfaction_ = 100;
	int age_;
	int dance_count_ = 0;
};

// Рабочий.
// День рабочего проходит за работой
class Worker : public Person {
public:
	Worker(const std::string& name, int age) : Person(name, age) {
	}

	// День рабочего проходит за работой
	void LiveADay() override {
		Work();
	}

	// Увеличивает счётчик сделанной работы на 1, уменьшает удовлетворённость на 5
	void Work() {
		++work_done_;
		SetSatisfaction(GetSatisfaction() - 5);
	}

	// Возвращает значение счётчика сделанной работы
	int GetWorkDone() const {
		return work_done_;
	}

protected:

	void AfterDance() override {
		const int age = GetAge();
		int incr = (age > 30 && age < 40) ? 2 : 1;
		SetSatisfaction(GetSatisfaction() + incr);
	}

private:
	int work_done_ = 0;
};

// Студент.
// День студента проходит за учёбой
class Student : public Person {
public:
	Student(const std::string& name, int age) : Person(name, age) {
	}

	// День студента проходит за учёбой
	void LiveADay() override {
		Study();
	}

	// Учёба увеличивает уровень знаний на 1, уменьшает уровень удовлетворённости на 3
	void Study() {
		++knowledge_;
		SetSatisfaction(GetSatisfaction() - 3);
	}

	// Возвращает уровень знаний
	int GetKnowledgeLevel() const {
		return knowledge_;
	}

private:
	int knowledge_ = 0;
};
